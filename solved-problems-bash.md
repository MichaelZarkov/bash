# Bash задачи и решения

В задачите, които изискват потребителско име, е ползвано "s45655".

## Прости команди

**Зад. 0:** Създайте файл permissions.txt в home директорията си. За него дайте единствено - read права 
на потребителя създал файла, write and exec на групата, read and exec на всички останали.
```bash
cd ~
touch permissions.txt
chmod a+rwx permissions.txt
chmod u-wx permissions.txt
chmod g-r permissions.txt
chmod o-w permissions.txt
```

**Зад. 1:** Намерете всички файлове в home директорията ви, които са променени в последния 1 час.
```bash
find ~ -mindepth 1 -mmin -60
```
Обяснение:
- `~` - home директорията ни.
- `-mindepth 1` - за да не изкарва на екрана и самата home директория.
- `-mmin -60` - изведи само тези, които са променени през последните 60 минути.
 
Забележка: `find` всъщност прави DFS(depth first search) на дървото на файловата система с дадената 
папка корен. И `-mindepth 1` пропуска корена, защото той е на ниво 0.

**Зад. 2:** Копирайте `/etc/services` в home директорията си. Прочетете го с командата `cat`. (Ако този
файл го няма, прочетете с `cat` произволен текстов файл например `/etc/passwd`).
```bash
cp /etc/services ~
cat services
```

**Зад. 3:** Създайте symlink на файла `/etc/passwd` в home директорията ви (да се казва например 
passwd_symlink).
```bash
ln /etc/passwd passwd_symlink -s
```

**Зад. 4:** Изведете всички обикновени ("regular") файлове, които `/etc` и нейните преки поддиректории
съдържат.
```bash
find /etc -mindepth 1 -maxdepth 2 -type f
```

**Зад. 5:** Изведете само първите 5 реда от `/etc/services`.
```bash
head /etc/services -n 5
```

**Зад. 6:** Изведете всички преки поддиректории на `/etc`.
```bash
find /etc -mindepth 1 -maxdepth 1 -type d
```

**Зад. 7:** Създайте файл, който да съдържа само последните 10 реда от изхода на 'Задача 6'.
```bash
find /etc -mindepth 1 -maxdepth 1 -type d | head >> last-10-rows.txt
```
Обяснение: Командата `find` ни намира нужните неща от 'Задача 6'. След това с оператора `|`, `head` поема
изхода на `find` и взима само първите 10 реда от него. Накрая с оператора `>>` пренасочваме изхода на
`head` към посочения файл.
    
**Зад. 8:** Изведете обикновените файлове по-големи от 42 байта в home директорията ви.
```bash
find ~ -type f -size +42c
```

**Зад. 9:** Изведете всички обикновени файлове в директорията `/tmp`, които са от вашата група, които 
имат write права за достъп за група или за останалите(o=w).
```bash
find /tmp -maxdepth 1 -type f -group students -perm /g=w,o=w
```
Обяснение: `students` е името на групата ми на Линукс машината. `-perm  /g=w,o=w` казва "дай ми 
файловете, които имат write permission за групата или за всички останали".
    
**Зад. 10:** Изведете всички файлове от <директория_по_избор>, които са по-нови от <файл_по_избор>.
```bash
find <дир_по_избор> -newerBB <файл_по_избор>
```
Забележка: Това решение би трябвало да е вярно, но отбелязвам, че не всички инсталации на Линукс пазят 
времето на създаването на файловете. Университетската инсталация не ги пази (до колкото разбирам) и 
затова ще изведе грешка. Виж флага `-newerXY <reference_file>` за повече инфо за филтриране по време 
спрямо файл.

**Зад. 11:** Изтрийте файловете в home директорията си по-нови от някой определен файл (подайте
на `rm` опция `-i`, за да може да изберете само тези, които искате да изтриете).
```bash
# Това го ползваме от предишната задача, за да ни изведе имената на по-новите файлове от дадения.
find ~ -newerBB <файл_по_избор>

cd ~

# Викаме 'rm' с wildcard патърна '*'. Шелът ще ни пита дали искаме да изтрием дадените файлове. С 'y' потвърждаваме, а с кой да е друг бутон отхвърляме.
rm * -i  
```    

**Зад. 12:** Намерете файловете в `/bin`, които могат да се четат, пишат и изпълняват от всички.
```bash
find /bin -mindepth 1 -maxdepth 1 -perm a=rwx
```

**Зад. 13:** Копирайте най-малкия файл от тези, намиращи се в `/etc`, в home директорията си.
```bash
cd /etc
cp $(ls /etc -S | tail -n 1) ~
```

**Зад. 14:**  
**a)** Копирайте всички файлове от `/etc`, които могат да се четат от всички, в директория `myetc` в
home директорията ви. Направете такава, ако нямате.
```bash
mkdir myetc
cp $(find /etc -mindepth 1 -maxdepth 1 -type f -perm -a=r) myetc
# 'find' намира нужните файлове и после с command substitution оператора '$(command)' подаваме изхода 
# на 'find' към 'cp', за да копира намерените файлове в директорията 'myetc'.
```
**b)** Когато вече сте получили `myetc` с файлове, архивирайте всички от тях, които започват с `c` в
архив, който се казва `c_start.tar`. Изтрийте директорията `myetc` и цялото ѝ съдържание, изтрийте
архива `c_start.tar`.
```bash
cd ~/myetc
tar --create --file=c_start.tar $(ls c*)  # Създаваме архива с имена започващи с 'c'.
cd ~
rm myetc -r
```

**Зад. 15:** Използвайки едно извикване на командата `find`, отпечатайте броя на редовете във всеки
обикновен файл в `/etc` директорията.
```bash
wc -l $(find /etc -mindepth 1 -maxdepth 1 -type f)
# Това е с едно викане на 'find', но има викане и на 'wc'. Брои ли се като решение?
```

## Pipes

**Зад. 0:** Сортирайте `/etc/passwd` лексикографски по поле UserID.
```bash
sort -k 3 -t : /etc/passwd
# Забележка: разделителят на колоните във файла '/etc/passwd' е ':' и UserID е трета колона.
# Ако се вгледаме в изхода на тази команда ще забележим, че редовете не са сортирани по нарастващ
# ред на UserID-тата. Ще видим на пример, че 1145 е преди 92. Това е, защото подреждаме лексикографски
# и наистина 1145 е преди 92 според лексикографската наредба (все пак това се иска в условието).
# Ако искаме да подредим по големината на числата UserID, просто добавяме '-n':
sort -n -k 3 -t : /etc/passwd
```

**Зад. 1:** Изведете само 1-ва и 5-та колона на файла `/etc/passwd` спрямо разделител `:`.
```bash
cut -d : -f 1,5 /etc/passwd
```

**Зад. 2:** Изведете съдържанието на файла `/etc/passwd` от 2-ри до 6-ти символ.
```bash
head -c 6 /etc/passwd | tail -c 5
# Забележка: това решение е вярно, само ако във файла всеки символ е точно един байт.

# Алтернатива, която работи и с Unicode:
file_as_string=$(cat /etc/passwd); printf "${file_as_string:1:5}\n"
# Това на български казва:
#   - сложи целия файл в променливата 'file_as_string'
#   - после изведи 5 символа(не байта!) като започваш от позиция 1 и сложи нов ред на края за четимост.
# 'printf' разбира от Unicode и знае как да извежда отделни символи дори да са по няколко байта.
# Дори и да не е Unicode може символът за нов ред да е два байта.
```

**Зад. 3:** Отпечатайте потребителските имена и техните home директории от `/etc/passwd`.
```bash
cut -d : -f 1,6 /etc/passwd
```

**Зад. 4:** Отпечатайте втората колона на `/etc/passwd`, разделена спрямо символ `/`.
```bash
cut -d/ -f2 /etc/passwd
```

**Зад. 5:** Изведете броя на байтовете, броя на символите и броя на редовете в `/etc/passwd`, заедно
и по отделно.
```bash
wc -c /etc/passwd  # Броят на байтовете.
wc -m /etc/passwd  # Броят на символите.
wc -l /etc/passwd  # Броят на редовете.
wc /etc/passwd     # Бройките на трите.
```

**Зад. 6:** С отделни команди, извадете от файла `/etc/passwd`:
1. първите 12 реда.
2. първите 26 символа.
3. всички редове, освен последните 4.
4. последните 17 реда.
5. 76-я ред (или друг произволен, ако нямате достатъчно редове).
6. последните 4 символа от 13-ти ред (символът за нов ред не е част от реда).
```bash
head -n12 /etc/passwd   # 1.
head -c 26 /etc/passwd  # 2. - това работи, само ако във файла всеки символ е точно един байт.
file_as_string=$(cat /etc/passwd); printf "${file_as_string:0:26}\n"  # 2. - работи и с Unicode.
head -n -4 /etc/passwd  # 3.
tail -n 17 /etc/passwd  # 4.
head -n 76 /etc/passwd | tail -n 1  # 5.

# е)
temp_str=$(head -n 13 /etc/passwd | tail -n 1)  # Запази ред 13 в променлива.
printf "${temp_str:(-4)}\n"  # Изведи последните 4 символа.
```

**Зад. 7:** Запаметете във файл в своята home директория резултатът от командата `df -P`.
Напишете команда, която извежда на екрана съдържанието на този файл, без първия ред (хедъра),
сортирано по второ поле (numeric).
```bash
df -P > fileSystemUsage.txt
tail -n +2 fileSystemUsage.txt | sort -n -k 2
```

**Зад. 8:** Запазете само потребителските имена от `/etc/passwd` във файл `users` във вашата home директория.
```bash
cut -d : -f 1 /etc/passwd > users
```

**Зад. 9:** Изпишете всички usernames от `/etc/passwd` с главни букви.
```bash
VAR=$(cut -d : -f 1 /etc/passwd); echo "${VAR^^}"  # ^^ прави всички букви главни.
```

**Зад. 10:**
1. Изведете реда от `/etc/passwd`, на който има информация за вашия потребител.
2. Изведете този ред и двата реда преди него.
3. Изведете този ред, двата преди него, и трите след него.
4. Изведете само реда, който се намира 2 реда преди реда, съдържащ информация за вашия потребител.
```bash
grep "s45655" /etc/passwd  # 1. ('s45655' е потребителското ми име)
grep -B 2 "s45655" /etc/passwd  # 2.
grep -A 3 -B 2 "s45655" /etc/passwd  # 3.
grep -B 2 "s45655" /etc/passwd | head -n 1  # 4.
```
**Зад. 11:** Изведете колко потребители не използват `/bin/bash` за login shell според `/etc/passwd`
(hint: `man 5 passwd` за информация какъв е форматът на `/etc/passwd`).
```bash
cut -d : -f 7 /etc/passwd | grep -v "/bin/bash" | wc -l
```

**Зад. 12:** Изведете само имената на хората с второ име по-дълго от 6 (>6) символа според `/etc/passwd`.
```bash
# Вариант 1 - извежда само фамилиите на хората.
cut -d : -f 5 /etc/passwd | cut -d" " -f 2 | cut -d"," -f 1 | grep "[а-яА-Я]\{7,\}"
# Вариант 2 - извежда име и фамилия.
cut -d : -f 5 /etc/passwd | cut -d"," -f 1 | grep " [а-яА-Я]\{7,\}"
```

**Зад. 13:** Изведете имената на хората с първо име по-късо от 8 (<=7) символа според `/etc/passwd`.
```bash
cut -d : -f 5 /etc/passwd | cut -d"," -f 1 | grep "^[а-яА-Я]\{1,7\} "
```

**Зад. 14:** Изведете целите редове от `/etc/passwd` за хората от предната задача.
```bash
# Вариант 1 - филтрираме със списъка от имената, който ни дава предната задача.
grep "$(cut -d : -f 5 /etc/passwd | cut -d"," -f 1 | grep "^[а-яА-Я]\{1,7\} ")" /etc/passwd
# Вариант 2 - директно правим регулярен израз.
grep ":[а-яА-Я]\{1,7\} " /etc/passwd
```

**Зад. 15:** Копирайте `<РЕПО>/exercises/data/emp.data` във вашата home директория. Посредством `awk`,
използвайки копирания файл за входни данни, изведете:
01. общия брой редове
02. третия ред
03. последното поле от всеки ред
04. последното поле на последния ред
05. всеки ред, който има повече от 4 полета
06. всеки ред, чието последно поле е по-голямо от 4
07. общия брой полета във всички редове
08. броя редове, в които се среща низът Beth
09. най-голямото трето поле и редът, който го съдържа
10. всеки ред, който има поне едно поле
11. всеки ред, който има повече от 17 знака
12. броя на полетата във всеки ред и самият ред
13. първите две полета от всеки ред, с разменени места
14. всеки ред така, че първите две полета да са с разменени места
15. всеки ред така, че на мястото на първото поле да има номер на реда
16. всеки ред без второто поле
17. за всеки ред, сумата от второ и трето поле
18. сумата на второ и трето поле от всеки ред

Файлът изглежда нещо от сорта на:
```
Beth    4.00    0
Dan     3.75    0
Kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18
```
```bash
# 01 различни варианти:
awk 'BEGIN { count = 0 } { ++count } END { print count }' emp.data  # с брояч
awk 'END { print FNR }' emp.data  # с ползване на built-in variables
# 02.
awk 'BEGIN { cnt = 1 } { if (cnt == 3) { print $0; exit; } ++cnt }' emp.data
awk '{ if (FNR == 3) { print $0; exit; }}' emp.data
# 03. 
awk '{ print $3 }' emp.data
awk '{ print $NF }' emp.data
# 04.
awk 'END { print $0 }' emp.data
# 05.
awk '{ if (4 < NF) print $0 }' emp.data
# 06.
awk '{ if (4 < $NF) print $0 }' emp.data
# 07.
awk 'BEGIN { fcnt = 0 } { fcnt += NF } END { print fcnt }' emp.data
# 08.
awk '/Beth/ { ++cnt } END { print cnt }' emp.data
# 09.
# Забележи как може да се запише текущия ред в променлива - със var=substr($0, 0).
awk 'max < $3 { max=$3; record=substr($0, 0) } END { print "Largest:", max; print record }' emp.data
# 10.
awk '0 < NF' emp.data
# 11.
awk '17 < length($0)' emp.data
# 12.
awk '{ print "Field count =", NF, $0 }' emp.data
# 13.
awk '{ print $2, $1 }' emp.data
# 14.
awk '{ print $2, $1, $3 }' emp.data
# 15.
awk '{ print FNR, "|", $2, $3 }' emp.data
# 16.
awk '{ print $1, $3 }' emp.data
# 17. 
awk '{ print ($2 + $3) }' emp.data
# 18.
awk '{ sum+= $2 + $3 } END { print sum }' emp.data
```

**Зад. 16:** Намерете само Group ID-то си от файлa `/etc/passwd`.
```bash
grep "^s45655" /etc/passwd | cut -d":" -f 4
# 's45655' е потребителското ми име.
```

**Зад. 17:** Колко коментара има във файла `/etc/services`? Коментарите се маркират със символа `#`,
след който всеки символ на реда се счита за коментар.
```bash
grep -c "#" /etc/services  # Ако видиш символа '#' в ред, преброй го.
```

**Зад. 18:** Колко файлове в `/bin` са shell script-oве? (Колко файлове в дадена директория са ASCII
text?)
```bash
cd /bin; awk -v total=0 '/^#!/ && FNR == 1 { ++total } END { print total }' $(ls /bin)
# Това решение проверява дали първите два символа във всеки файл в /bin са "#!".
# Защото shell скриптовете започват така. Може би има и по-добро решение.
```

**Зад. 19:** Направете списък с директориите на вашата файлова система, до които нямате достъп.
Понеже файловата система може да е много голяма, търсете до 3 нива на дълбочина.
```bash
find / -maxdepth 3 -false 2>&1 | cut -d" " -f 2 | cut -d":" -f 1
# Пускаме find от корена '/' и извеждаме за кои директории е дало permission denied.
# 'cut', за да извлечем само имената им.
```

**Зад. 20:** Създайте следната файлова йерархия в home директорията ви:
`dir5/file1 dir5/file2 dir5/file3`. 
Посредством vi въведете следното съдържание:
- `file1`
  ```
  1   
  2
  3
  ```
- `file2`
  ```
  s
  a
  d
  f
  ```
- `file3`
  ```
  3
  2
  1
  45
  42
  14
  1
  52
  ```
Изведете на екрана:
1. статистика за броя редове, думи и символи за всеки един файл
2. статистика за броя редове и символи за всички файлове
3. общия брой редове на трите файла
```bash
wc -l -w -m file1 file2 file3 | head -n 3  # 1.
wc -l -m file1 file2 file3 | tail -n 1  # 2.
wc -l $(ls ~/dir5) | tail -n 1  # 3.
```

**Зад. 21:** Във `file2` (inplace) подменете всички малки букви с главни.
```bash
printf "$(awk '{ print toupper($0) }' file2)" > file2
# Това изглежда доста грозно. Мисля, че със 'sed' може да се направи "по-хубаво".
```

**Зад. 22:** Във `file3` (inplace) изтрийте всички "1"-ци.
```bash
sed 's/1//' -i file3 
```

**Зад. 23:** Изведете статистика за най-често срещаните символи в трите файла.
```bash
cd ~/dir5;
for i in {33..126};  # For each printable character.
do
    toChar=$(printf %b $(printf "\%o" $i));           # Convert 'i' to char.
    count=$(cat $(ls) | tr -c -d "$toChar" | wc -c);  # Count the occurrences of 'toChar' in all 3 files.
    if [ "$toChar" == "*" ]; then  # The space between [ and " is mandatory!
        printf "* %d\n" $count;    # Print * separately because it has special meaning.
    else 
        printf "%c %d\n" $toChar $count;
    fi
done
```

**Зад. 24:** Направете нов файл с име по ваш избор, чието съдържание е конкатенирани съдържанията
на `file{1,2,3}`.
```bash
cd ~/dir5; cat $(ls) > fileConcat
```

**Зад. 25:** Прочетете текстов файл `file1` и направете всички главни букви малки като запишете
резултата във `file2`.
```bash
printf "$(awk '{ print tolower($0) }' file1)" > file2
```
    
**Зад. 25:** Намерете броя на символите, различни от буквата `а` във файла `/etc/passwd`.
```bash 
tr -d 'a' < /etc/passwd | wc -c
```

**Зад. 26:** Намерете броя на уникалните символи, използвани в имената на потребителите от `/etc/passwd`.  
Забележка: приемам,че това означава да изброим колко различни символа се срещат в потребителските имена. 
На пример, ако имаме имената "Иван София Мария", различните символи ще са 'ивансофямр' и значи броят им 
ще е 10.
```bash 
cut -d':' -f 1 /etc/passwd | fold -w 1 | sort | tr -d '\n' | tr -s -c '' | wc -c
# Това сигурно може и по-четимо да се направи.
# 1. Отделяме само потребителските имена от '/etc/passwd'.
# 2. Правим така, че всеки символ да е на нов ред.
# 3. Сортираме редовете (в случая символите).
# 4. Махаме новите редове.
# 5. Махаме повторенията (те., ако имаме "mmnnnpp" става "mnp").
# 6. Броим кои символи са останали и това е нашият отговор.
```

**Зад. 27:** Отпечатайте всички редове на файла `/etc/passwd`, които не съдържат символния низ `ов`.
```bash
grep -v 'ов' /etc/passwd 
```

**Зад. 28:** Отпечатайте последната цифра на UID на всички редове между 28-ми и 46-ред в `/etc/passwd`.
```bash
awk -F ':' '28 <= FNR && FNR <= 46 { print ($3 % 10) }' /etc/passwd
```

**Зад. 29:** Отпечатайте правата (permissions) и имената на всички файлове, до които имате read достъп,
намиращи се в директорията `/tmp` (hint: `man find`, вижте `-readable`).
```bash
find /tmp -mindepth 1 -maxdepth 1 -readable -printf "%M %f\n"
# Интересно, че като го пуснах нямаше файлове с read достъп.
# %M печата правата, %f печата името.
```

**Зад. 30:** Намерете имената на 10-те файла във вашата home директория, чието съдържание е редактирано
най-скоро. На първо място трябва да бъде най-скоро редактираният файл. Намерете 10-те най-скоро
достъпени файла.(hint: Unix time)
```bash
find ~ -mindepth 1 -printf "%T@ %p\n" | sort -k 1 -n -r | head | cut -f 2 -d' '  # recently edited
find ~ -mindepth 1 -printf "%A@ %p\n" | sort -k 1 -n -r | head | cut -f 2 -d' '  # recently accessed
# Извеждаме на стандартния изход съответно времето на последна/ен редакция/достъп и сортираме по него.
```

**Зад. 30:** Да приемем, че файловете, които съдържат **C** код, завършват на `.c` или `.h`.
Колко на брой са те в директорията `/usr/include`? Колко реда **C** код има в тези файлове?
```bash
ls /usr/include | awk '/\.c$/ || /\.h$/ { ++count } END { print count }'      # брой файлове
cd /usr/include; wc -l $(ls /usr/include | awk '/\.c$/ || /\.h$/ { print }')  # брой редове
```

**Зад. 31:** Даден ви е ASCII текстов файл - `/etc/services`. Отпечатайте хистограма на 10-те най-често
срещани думи. Дума наричаме непразна последователност от букви. Не правим разлика между главни и малки
букви. Хистограма наричаме поредица от редове, всеки от които има вида:
<брой срещания> <какво се среща толкова пъти>.
```bash
# backslash казва на bash, че командата продължава на другия ред.
# Какво точно правим:
# 1. С grep изваждаме само думите от файла.
# 2. Правим всички букви на малки и сортираме.
# 3. С awk броим срещанията на всяка дума.
# 4. Сортираме по броя на срещанията.
grep -E -o '[a-zA-Z]+' /etc/services | awk '{ print tolower($0) }' | sort | \
awk \
'{                                                   
    if (prevWord == $0)
        ++count;
    else {
        if (count != 0)
            print count, prevWord;
        count=1;
        prevWord=$0;
    }
}
END { print count, prevWord; }' | \
sort -k 1 -n -r | head
```
Забележка: Тая команда с всичките нови редове изглежда, че няма да работи, но би трябвало просто 
copy-paste в терминала и всичко да е точно. Това се отнася и за други команди, които са така зловещо
изглеждащи.

**Зад. 32:** Вземете факултетните номера на студентите (описани във файла `<РЕПО>/exercises/data/mypasswd.txt`)
от СИ и ги запишете във файл `si.txt` сортирани. Студент е част от СИ, ако home директорията на този
потребител (според `<РЕПО>/exercises/data/mypasswd.txt`) се намира в `/home/SI` директорията.
```bash
# Изтегли файла.
wget https://raw.githubusercontent.com/avelin/fmi-os/master/exercises/data/mypasswd.txt
# Направи нужните трансформации.
cut -f6 -d':' mypasswd.txt | cut -f3,4 -d'/' | grep -E '^SI/s[0-9]+' | cut -f2 -d's' | sort -n > si.txt
```

**Зад. 32:** За всяка група от `/etc/group` изпишете "Hello, <група>", като ако това е вашата група,
напишете "Hello, <група> - I am here!".
```bash
myGroupName=$(groups s45655 | cut -f3 -d' ') \
awk -F: \
'BEGIN {
    cmd = "echo $myGroupName";
    cmd | getline grName;
    close(cmd);
}
{
    if (grName == $1) print "Hello,", $1, "- I am here!";
    else              print "Hello,", $1;
}' /etc/group
```

**Зад. 33:** Shell Script-овете са файлове, които по конвенция имат разширение `.sh`. Всеки такъв файл
започва с `#!<interpreter>` , където `<interpreter>` указва на операционната система какъв интерпретатор
да пусне (пр: `#!/bin/bash`, `#!/usr/bin/python3 -u`).
Намерете всички `.sh` файлове в директорията `/usr` и нейните поддиректории, и проверете кой е
най-често използваният интерпретатор.
```bash
#!/bin/bash

interpreters="$(head -q -n 1 $(find /usr -mindepth 1 -type f -regex ".*\.sh") | \
                grep "^#!" | tr -d "#!" | sed "s/ *//";)";

declare -A intrpCnt;  # Асоциативен списък.

while read line;
do
    intrpCnt["$line"]=$(( intrpCnt["$line"]+=1 ))
done <<< $interpreters

for key in "${!intrpCnt[@]}"
do
    echo "Interpreter: $key | Number of users: ${intrpCnt[$key]}";
done
```
```bash
# За тестване. Трябва сборът от върнатите бройки да е равен на общия брой.
# Връща общия брой shell скриптове.
head -q -n 1 $(find /usr -mindepth 1 -type f -regex ".*\.sh") | grep "^#!" | wc -l
```

**Зад. 34:** 
1. Изведете GID-овете на 5-те най-големи групи спрямо броя потребители, за които съответната група е
   основна (primary).
2. (*) Изведете имената на съответните групи.

Hint: `/etc/passwd`, `man 5 passwd`.

Скрипт за 1.
```bash    
#!/bin/bash
GIDs="$(cut -f4 -d':' /etc/passwd)";
declare -A arrGIDcounts;
while read line;
do
        arrGIDcounts["$line"]=$(( arrGIDcounts["$line"] + 1 ))
done <<< $GIDs

for key in "${!arrGIDcounts[@]}"
do
        GIDcounts+=$(echo "Group $key|User_count ${arrGIDcounts[$key]}\n");
done

printf "$GIDcounts" | sort -r -d -t' ' -k3 | head -n5
```
    
